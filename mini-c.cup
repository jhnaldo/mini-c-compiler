// Copyright (c) 2014 Jihyeok Park
// KAIST CS420 Project

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

action code {:
:}

parser code {:
    /* this part is included in the parser class */
    public static void main (String args[]) throws Exception{
        new parser(new Yylex(System.in)).parse();
    }
:}

terminal UMINUS, MULT,DIV,PLUS,MINUS,LT,GT,LTE,GTE,EQ,NEQ;
terminal ASSIGN,LPAREN,RPAREN,LBRACE,RBRACE,LSBRACE,RSBRACE,COMMA,SEMI, COLON;
terminal INT,FLOAT,RETURN,WHILE,DO,FOR,IF,ELSE,SWITCH,CASE,DEFAULT,BREAK;
terminal Integer    INTNUM;
terminal Float      FLOATNUM;
terminal String     ID;

non terminal Program        program;
non terminal DeclList       decl_list;
non terminal FuncList       func_list;
non terminal Decl           decl;
non terminal IdentList      ident_list;
non terminal Ident          ident;
non terminal Func           func;
non terminal ParamList      param_list;
non terminal Param          param;
non terminal Type           type;
non terminal CompStmt       comp_stmt;
non terminal StmtList       stmt_list;
non terminal Stmt           stmt;
non terminal AssignStmt     assign_stmt;
non terminal Assign         assign;
non terminal CallStmt       call_stmt;
non terminal Call           call;
non terminal RetStmt        ret_stmt;
non terminal WhileStmt      while_stmt;
non terminal ForStmt        for_stmt;
non terminal IfStmt         if_stmt;
non terminal SwitchStmt     switch_stmt;
non terminal CaseList       case_list;
non terminal CaseStmt       case_stmt;
non terminal DefaultStmt    default_stmt;
non terminal Expr           expr;
non terminal ArgList        arg_list;

precedence right    ASSIGN;
precedence left     EQ, NEQ;
precedence left     GT, LT, GTE, LTE;
precedence left     PLUS, MINUS;
precedence left     MULT, DIV;
precedence right    UMINUS;
precedence left     LPAREN, RPAREN;

program ::= 
        |   decl_list:dl
            {: Program p = new Program(dl, null); :}
        |   func_list:fl
            {: Program p = new Program(null, fl); :}
        |   decl_list:dl func_list:fl
            {: Program p = new Program(dl, fl); :}
        ;

decl_list ::=
            decl:d
            {: RESULT = new DeclList(d); :}
        |   decl_list:dl decl:d
            {: dl.add(d); RESULT = dl; :}
        ;

func_list ::=
            func:f
            {: RESULT = new FuncList(f); :}
        |   func_list:fl func:f
            {: fl.add(f); RESULT = fl; :}
        ;

decl ::=
            type:t ident_list:idl
            {: RESULT = new Decl(t,idl); :}
        ;

ident_list ::=
            ident:id
            {: RESULT = new IdentList(id); :}
        |   ident_list:idl COMMA ident:id
            {: idl.add(id); RESULT = idl; :}
        ;

ident ::=
            ID:id
            {: RESULT = new SingleIdent(id); :}
        |   ID:id LSBRACE INTNUM:k RSBRACE
            {: RESULT = new ArrayIdent(id,k); :}
        ;

func ::=
            type:t ID:fn LPAREN RPAREN comp_stmt:cs
            {: RESULT = new Func(t,fn,null,cs); :}
        |   type:t ID:fn LPAREN param_list:pl RPAREN comp_stmt:cs
            {: RESULT = new Func(t,fn,pl,cs); :}
        ;

param_list ::=
            param:p
            {: RESULT = new ParamList(p); :}
        |   param_list:pl COMMA param:p
            {: pl.add(p); RESULT = pl; :}
        ;

param ::=
            type:t ident:id
            {: RESULT = new Param(t,id); :}
        ;

type ::=
            INT
            {: RESULT = new Type(0); :}
        |   FLOAT
            {: RESULT = new Type(1); :}
        ;

comp_stmt ::=
            LBRACE stmt_list:sl RBRACE
            {: RESULT = new CompStmt(null, sl); :}
        |   LBRACE decl_list:dl stmt_list:sl RBRACE
            {: RESULT = new CompStmt(dl, sl); :}
        ;

stmt_list ::=
            {: RESULT = new StmtList(); :}
        |   stmt_list:sl stmt:s
            {: if(s!=null) { sl.add(s); } RESULT = sl; :}
        ;

stmt ::=
            assign_stmt:as
            {: RESULT = as; :}
        |   call_stmt:ca
            {: RESULT = ca; :}
        |   ret_stmt:ret
            {: RESULT = ret; :}
        |   while_stmt:wh
            {: RESULT = wh; :}
        |   for_stmt:for_st
            {: RESULT = for_st; :}
        |   if_stmt:if_st
            {: RESULT = if_st; :}
        |   switch_stmt:sw
            {: RESULT = sw; :}
        |   comp_stmt:cs
            {: RESULT = cs; :}
        |   SEMI
            {: RESULT = null; :}
        ;

assign_stmt ::=
            assign:as SEMI
            {: RESULT = new AssignStmt(as); :}
        ;

assign ::=
            ID:id ASSIGN expr:e
            {: RESULT = new Assign(id,null,e); :}
        |   ID:id LSBRACE expr:idx RSBRACE ASSIGN expr:e
            {: RESULT = new Assign(id,idx,e); :}
        ;

call_stmt ::=
            call:c SEMI
            {: RESULT = new CallStmt(c); :}
        ;
call ::=
            ID:id LPAREN RPAREN
            {: RESULT = new Call(id,null); :}
        |   ID:id LPAREN arg_list:al RPAREN
            {: RESULT = new Call(id,al); :}
        ;

ret_stmt ::=
            RETURN SEMI
            {: RESULT = new RetStmt(null); :}
        |   RETURN expr:e SEMI
            {: RESULT = new RetStmt(e); :}
        ;

while_stmt ::=
            WHILE LPAREN expr:e RPAREN stmt:s
            {: RESULT = new WhileStmt(e,s,false); :}
        |   DO stmt:s WHILE LPAREN expr:e RPAREN
            {: RESULT = new WhileStmt(e,s,true); :}
        ;

for_stmt ::=
            FOR LPAREN assign:init SEMI expr:cond SEMI assign:as RPAREN stmt:st
            {: RESULT = new ForStmt(init,cond,as,st); :}
        ;

if_stmt ::=
            IF LPAREN expr:cond RPAREN stmt:th
            {: RESULT = new IfStmt(cond,th,null); :}
        |   IF LPAREN expr:cond RPAREN stmt:th ELSE stmt:el
            {: RESULT = new IfStmt(cond,th,el); :}
        ;

switch_stmt ::=
            SWITCH LPAREN ident:id RPAREN LBRACE case_list:cl RBRACE
            {: RESULT = new SwitchStmt(id,cl,null); :}
        |   SWITCH LPAREN ident:id RPAREN LBRACE case_list:cl default_stmt:ds RBRACE
            {: RESULT = new SwitchStmt(id,cl,ds); :}
        ;

case_list ::=
            {: RESULT = new CaseList(); :}
        |   case_list:cl case_stmt:cs
            {: cl.add(cs); RESULT = new CaseList(); :}
        ;

case_stmt ::=
            CASE INTNUM:k COLON stmt_list:sl
            {: RESULT = new CaseStmt(k,sl,false); :}
        |   CASE INTNUM:k COLON stmt_list:sl BREAK SEMI
            {: RESULT = new CaseStmt(k,sl,true); :}
        ;

default_stmt ::=
            DEFAULT COLON stmt_list:sl
            {: RESULT = new DefaultStmt(sl,false); :}
        |   DEFAULT COLON stmt_list:sl BREAK SEMI
            {: RESULT = new DefaultStmt(sl,true); :}
        ;

expr ::=
            UMINUS expr
        |   expr MULT expr
        |   expr DIV expr
        |   expr PLUS expr
        |   expr MINUS expr
        |   expr GT expr
        |   expr LT expr
        |   expr GTE expr
        |   expr LTE expr
        |   expr EQ expr
        |   expr NEQ expr
        |   call
        |   INTNUM
        |   FLOATNUM
        |   ID
        |   ID LSBRACE expr RSBRACE
        |   LPAREN expr RPAREN
        ;

arg_list ::=
            expr:e
            {: RESULT = new ArgList(e); :}
        |   arg_list COMMA expr
        ;
